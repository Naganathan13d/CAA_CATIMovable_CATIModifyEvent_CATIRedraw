// COPYRIGHT Dassault Systemes 2022
//===================================================================
//
// TRAStateCommand.cpp
// The state chart based command: TRAStateCommand
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Jun 2022  Creation: Code generated by the CAA wizard  Dell
//===================================================================
#include "TRAStateCommand.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
#include "CATFrmEditor.h"
#include "CATDocument.h"
#include "CATIDocRoots.h"
#include "CATIProduct.h"
#include<iostream>
using namespace std;




CATCreateClass( TRAStateCommand);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TRAStateCommand::TRAStateCommand() :
  CATStateCommand ("TRAStateCommand", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  
{
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TRAStateCommand::~TRAStateCommand()
{
   
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TRAStateCommand::BuildGraph()
{

	CATFrmEditor * pEditor = NULL;

	pEditor = CATFrmEditor::GetCurrentEditor();
	if(!!pEditor)
	{
		CATDocument *  pDocument = pEditor->GetDocument();
		if(!!pDocument)
		{
			std::cout<<"doc is received" <<std::endl;
		}

	

	CATIDocRoots *piDocRootsOnDoc = NULL;
	HRESULT rc = pDocument->QueryInterface(IID_CATIDocRoots,
		                      (void**) &piDocRootsOnDoc);

	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();

	std::cout << std::endl << " RootProducts List created " << std::endl ;


	CATIProduct_var spRootProduct = NULL_var;

	spRootProduct = (*pRootProducts)[1];
			delete pRootProducts;
			pRootProducts = NULL;
	CATIProduct *piProductOnRoot = NULL;
	rc = spRootProduct->QueryInterface(IID_CATIProduct,
		                               (void**) &piProductOnRoot);

	std::cout << std::endl << " Got the Root Product " << std::endl ;

	/* ---------------------------------------*/
	/* 3. Retrieves children under the root   */
	/* ---------------------------------------*/
	
	int nbOfDirectChidren = piProductOnRoot -> GetChildrenCount() ;
	cout << " Number of direct children under the root = " << nbOfDirectChidren << endl << flush;
	
	// then on a root product, get all the children agregated to it.
	CATListValCATBaseUnknown_var*   ListChildren =
		piProductOnRoot->GetAllChildren();
/** @anchor err_2 piProductOnRoot not set to NULL after release */ 
	piProductOnRoot -> Release();
	piProductOnRoot = NULL;
	if(NULL != ListChildren)
	{
		
		int numberOfChildren = ListChildren->Size();
		cout << " Number of all children under the root = " << numberOfChildren << endl << flush;

		/* -----------------------------------------------------------*/
		/*  4. For each child, get its partNumber, and InstanceName   */
		/* -----------------------------------------------------------*/
		CATIProduct_var spChild = NULL_var;
		for (int i=1;i<=numberOfChildren;i++)
		{
			spChild = (*ListChildren)[i];
/** @anchor err_3 spChild not tested before use ( if !! ) */ 
			 
			CATUnicodeString partNumber = spChild -> GetPartNumber();
			CATUnicodeString instanceName (" ");
			rc = spChild -> GetPrdInstanceName ( instanceName ) ;
			if  ( FAILED(rc) ) 
			
			cout << " child number : " << i << endl << flush;
			cout << " has as part number : " << partNumber.CastToCharPtr()  << endl << flush;
			cout << " and as instanceName : " << instanceName.CastToCharPtr() << endl << endl << flush;
		}
		delete ListChildren;
		ListChildren=NULL;

	}




 
}


}